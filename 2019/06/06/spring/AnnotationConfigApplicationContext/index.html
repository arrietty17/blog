<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.8.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="Spring源码解析 – AnnotationConfigApplicationContext容器创建过程">




  <meta name="keywords" content="Spring,">





  <link rel="alternate" href="/blog/default" title="arrietty">




  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=1.1">



<link rel="canonical" href="https://arrietty17.github.io/blog/2019/06/06/spring/AnnotationConfigApplicationContext/">


<meta name="description" content="Spring在BeanFactory基础上提供了一些列具体容器的实现，其中AnnotationConfigApplicationContext是一个用来管理注解bean的容器，从AnnotationConfigApplicationContext的实现结构图中可以看出：  AnnotationConfigApplicationContext继承GenericApplicationContext这个">
<meta name="keywords" content="Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring源码解析 – AnnotationConfigApplicationContext容器创建过程">
<meta property="og:url" content="https://arrietty17.github.io/blog/2019/06/06/spring/AnnotationConfigApplicationContext/index.html">
<meta property="og:site_name" content="arrietty">
<meta property="og:description" content="Spring在BeanFactory基础上提供了一些列具体容器的实现，其中AnnotationConfigApplicationContext是一个用来管理注解bean的容器，从AnnotationConfigApplicationContext的实现结构图中可以看出：  AnnotationConfigApplicationContext继承GenericApplicationContext这个">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-06T12:11:27.702Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring源码解析 – AnnotationConfigApplicationContext容器创建过程">
<meta name="twitter:description" content="Spring在BeanFactory基础上提供了一些列具体容器的实现，其中AnnotationConfigApplicationContext是一个用来管理注解bean的容器，从AnnotationConfigApplicationContext的实现结构图中可以看出：  AnnotationConfigApplicationContext继承GenericApplicationContext这个">


<link rel="stylesheet" type="text/css" href="/blog/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Spring源码解析 – AnnotationConfigApplicationContext容器创建过程 - arrietty </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/blog/." class="logo">arrietty</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/blog/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/blog/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Spring源码解析 – AnnotationConfigApplicationContext容器创建过程
        
      </h1>

      <time class="post-time">
          Jun 06 2019
      </time>
    </header>



    
            <div class="post-content">
            <p>Spring在BeanFactory基础上提供了一些列具体容器的实现，其中AnnotationConfigApplicationContext是一个用来管理注解bean的容器，从AnnotationConfigApplicationContext的实现结构图中可以看出：</p>
<ul>
<li>AnnotationConfigApplicationContext继承GenericApplicationContext这个通用应用上下文，GenericApplicationContext内部定义了一个DefaultListableBeanFactory实例，GenericApplicationContext实现了BeanDefinitionRegistry接口，所以可以通过AnnotationConfigApplicationContext实例注册bean defintion，然后调用refresh()方法来初始化上下文。</li>
<li>AnnotationConfigApplicationContext继承AbstractApplicationContext，AbstractApplicationContext提供了ApplicationContext的抽象实现。</li>
</ul>
<p>下面通过一个示例分析AnnotationConfigApplicationContext的初始化过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext applicationContext  = new AnnotationConfigApplicationContext(ExtensionConfig.class);</span><br></pre></td></tr></table></figure></p>
<p>构造函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 //1. 初始化bean读取器和扫描器;</span><br><span class="line">2     //调用父类GenericApplicationContext无参构造函数，初始化一个BeanFactory: DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory()</span><br><span class="line">3    this();</span><br><span class="line">4 //2.注册bean配置类</span><br><span class="line">5    register(annotatedClasses);</span><br><span class="line">6 //3.刷新上下文</span><br><span class="line">7    refresh();</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="1、this-初始化bean读取器和扫描器"><a href="#1、this-初始化bean读取器和扫描器" class="headerlink" title="1、this() 初始化bean读取器和扫描器"></a>1、this() 初始化bean读取器和扫描器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 public AnnotationConfigApplicationContext() &#123;</span><br><span class="line">2     //在IOC容器中初始化一个 注解bean读取器AnnotatedBeanDefinitionReader</span><br><span class="line">3    this.reader = new AnnotatedBeanDefinitionReader(this);</span><br><span class="line">4    //在IOC容器中初始化一个 按类路径扫描注解bean的 扫描器</span><br><span class="line">5    this.scanner = new ClassPathBeanDefinitionScanner(this);</span><br></pre></td></tr></table></figure>
<p>GenericApplicationContext部分代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 public class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry &#123;</span><br><span class="line">2 private final DefaultListableBeanFactory beanFactory;</span><br><span class="line">3 </span><br><span class="line">4 //初始化一个BeanFactory</span><br><span class="line">5 public GenericApplicationContext() &#123;</span><br><span class="line">6       this.beanFactory = new DefaultListableBeanFactory();</span><br><span class="line">7     &#125;</span><br><span class="line">8     …</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-register-annotatedClasses"><a href="#2-register-annotatedClasses" class="headerlink" title="2. register(annotatedClasses)"></a>2. register(annotatedClasses)</h5><pre><code>注册bean配置类, AnnotationConfigApplicationContext容器通过AnnotatedBeanDefinitionReader的register方法实现注解bean的读取，具体源码如下：
AnnotationConfigApplicationContext.java中register方法
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">1 public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line"> 2    synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line"> 3       //1.刷新前的预处理</span><br><span class="line"> 4       prepareRefresh();</span><br><span class="line"> 5 </span><br><span class="line"> 6       //2.获取刷新后的内部Bean工厂</span><br><span class="line"> 7       ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"> 8 </span><br><span class="line"> 9       //3.BeanFactory的预准备工作</span><br><span class="line">10       prepareBeanFactory(beanFactory);</span><br><span class="line">11 </span><br><span class="line">12       try &#123;</span><br><span class="line">13          // BeanFactory准备工作完成后，可以做一些后置处理工作，</span><br><span class="line">14 　　　　  // 4.空方法，用于在容器的子类中扩展</span><br><span class="line">15          postProcessBeanFactory(beanFactory);</span><br><span class="line">16 </span><br><span class="line">17          // 5. 执行BeanFactoryPostProcessor的方法，BeanFactory的后置处理器，在BeanFactory标准初始化之后执行的</span><br><span class="line">18          invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">19 </span><br><span class="line">20          // 6. 注册BeanPostProcessor（Bean的后置处理器）,用于拦截bean创建过程</span><br><span class="line">21          registerBeanPostProcessors(beanFactory);</span><br><span class="line">22 </span><br><span class="line">23          // 7. 初始化MessageSource组件（做国际化功能；消息绑定，消息解析）</span><br><span class="line">24          initMessageSource();</span><br><span class="line">25 </span><br><span class="line">26          // 8. 初始化事件派发器</span><br><span class="line">27          initApplicationEventMulticaster();</span><br><span class="line">28 </span><br><span class="line">29          // 9.空方法，可以用于子类实现在容器刷新时自定义逻辑</span><br><span class="line">30          onRefresh();</span><br><span class="line">31 </span><br><span class="line">32          // 10. 注册时间监听器，将所有项目里面的ApplicationListener注册到容器中来</span><br><span class="line">33          registerListeners();</span><br><span class="line">34 </span><br><span class="line">35          // 11. 初始化所有剩下的单实例bean,单例bean在初始化容器时创建，原型bean在获取时（getbean）时创建</span><br><span class="line">36          finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">37 </span><br><span class="line">38          // 12. 完成BeanFactory的初始化创建工作，IOC容器就创建完成；</span><br><span class="line">39          finishRefresh();</span><br><span class="line">40       &#125;</span><br><span class="line">41 </span><br><span class="line">42       catch (BeansException ex) &#123;</span><br><span class="line">43          if (logger.isWarnEnabled()) &#123;</span><br><span class="line">44             logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">45                   &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">46          &#125;</span><br><span class="line">47 </span><br><span class="line">48          // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">49          destroyBeans();</span><br><span class="line">50 </span><br><span class="line">51          // Reset &apos;active&apos; flag.</span><br><span class="line">52          cancelRefresh(ex);</span><br><span class="line">53 </span><br><span class="line">54          // Propagate exception to caller.</span><br><span class="line">55          throw ex;</span><br><span class="line">56       &#125;</span><br><span class="line">57 </span><br><span class="line">58       finally &#123;</span><br><span class="line">59          // Reset common introspection caches in Spring&apos;s core, since we</span><br><span class="line">60          // might not ever need metadata for singleton beans anymore...</span><br><span class="line">61          resetCommonCaches();</span><br><span class="line">62       &#125;</span><br><span class="line">63    &#125;</span><br><span class="line">64 &#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-refresh-刷新上下文"><a href="#3-refresh-刷新上下文" class="headerlink" title="3. refresh()刷新上下文"></a>3. refresh()刷新上下文</h5><p>refresh方法在AbstractApplicationContext容器中实现，refresh()方法的作用加载或者刷新当前的配置信息，如果已经存在spring容器，则先销毁之前的容器，重新创建spring容器，载入bean定义，完成容器初始化工作，所以可以看出AnnotationConfigApplicationContext容器是通过调用其父类AbstractApplicationContext的refresh()函数启动整个IoC容器完成对Bean定义的载入。     </p>
<p>AbstractApplicationContext.java中refresh方法的实现代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"> 1 public void refresh() throws BeansException, IllegalStateException &#123;</span><br><span class="line"> 2    synchronized (this.startupShutdownMonitor) &#123;</span><br><span class="line"> 3       //1.刷新前的预处理</span><br><span class="line"> 4       prepareRefresh();</span><br><span class="line"> 5 </span><br><span class="line"> 6       //2.获取刷新后的内部Bean工厂</span><br><span class="line"> 7       ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"> 8 </span><br><span class="line"> 9       //3.BeanFactory的预准备工作</span><br><span class="line">10       prepareBeanFactory(beanFactory);</span><br><span class="line">11 </span><br><span class="line">12       try &#123;</span><br><span class="line">13          // BeanFactory准备工作完成后，可以做一些后置处理工作，</span><br><span class="line">14 　　　　  // 4.空方法，用于在容器的子类中扩展</span><br><span class="line">15          postProcessBeanFactory(beanFactory);</span><br><span class="line">16 </span><br><span class="line">17          // 5. 执行BeanFactoryPostProcessor的方法，BeanFactory的后置处理器，在BeanFactory标准初始化之后执行的</span><br><span class="line">18          invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">19 </span><br><span class="line">20          // 6. 注册BeanPostProcessor（Bean的后置处理器）,用于拦截bean创建过程</span><br><span class="line">21          registerBeanPostProcessors(beanFactory);</span><br><span class="line">22 </span><br><span class="line">23          // 7. 初始化MessageSource组件（做国际化功能；消息绑定，消息解析）</span><br><span class="line">24          initMessageSource();</span><br><span class="line">25 </span><br><span class="line">26          // 8. 初始化事件派发器</span><br><span class="line">27          initApplicationEventMulticaster();</span><br><span class="line">28 </span><br><span class="line">29          // 9.空方法，可以用于子类实现在容器刷新时自定义逻辑</span><br><span class="line">30          onRefresh();</span><br><span class="line">31 </span><br><span class="line">32          // 10. 注册时间监听器，将所有项目里面的ApplicationListener注册到容器中来</span><br><span class="line">33          registerListeners();</span><br><span class="line">34 </span><br><span class="line">35          // 11. 初始化所有剩下的单实例bean,单例bean在初始化容器时创建，原型bean在获取时（getbean）时创建</span><br><span class="line">36          finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">37 </span><br><span class="line">38          // 12. 完成BeanFactory的初始化创建工作，IOC容器就创建完成；</span><br><span class="line">39          finishRefresh();</span><br><span class="line">40       &#125;</span><br><span class="line">41 </span><br><span class="line">42       catch (BeansException ex) &#123;</span><br><span class="line">43          if (logger.isWarnEnabled()) &#123;</span><br><span class="line">44             logger.warn(&quot;Exception encountered during context initialization - &quot; +</span><br><span class="line">45                   &quot;cancelling refresh attempt: &quot; + ex);</span><br><span class="line">46          &#125;</span><br><span class="line">47 </span><br><span class="line">48          // Destroy already created singletons to avoid dangling resources.</span><br><span class="line">49          destroyBeans();</span><br><span class="line">50 </span><br><span class="line">51          // Reset &apos;active&apos; flag.</span><br><span class="line">52          cancelRefresh(ex);</span><br><span class="line">53 </span><br><span class="line">54          // Propagate exception to caller.</span><br><span class="line">55          throw ex;</span><br><span class="line">56       &#125;</span><br><span class="line">57 </span><br><span class="line">58       finally &#123;</span><br><span class="line">59          // Reset common introspection caches in Spring&apos;s core, since we</span><br><span class="line">60          // might not ever need metadata for singleton beans anymore...</span><br><span class="line">61          resetCommonCaches();</span><br><span class="line">62       &#125;</span><br><span class="line">63    &#125;</span><br><span class="line">64 &#125;</span><br></pre></td></tr></table></figure></p>
<p>具体分析refresh中的函数逻辑：<br>1.刷新预处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> 1 protected void prepareRefresh() &#123;</span><br><span class="line"> 2 　　//设置容器启动时间</span><br><span class="line"> 3    this.startupDate = System.currentTimeMillis();</span><br><span class="line"> 4 　　//启动标识</span><br><span class="line"> 5    this.closed.set(false);</span><br><span class="line"> 6    this.active.set(true);</span><br><span class="line"> 7 </span><br><span class="line"> 8    if (logger.isInfoEnabled()) &#123;</span><br><span class="line"> 9       logger.info(&quot;Refreshing &quot; + this);</span><br><span class="line">10    &#125;</span><br><span class="line">11 </span><br><span class="line">12    //空方法，用于子容器自定义个性化的属性设置方法</span><br><span class="line">13    initPropertySources();</span><br><span class="line">14    //检验属性的合法等</span><br><span class="line">15    getEnvironment().validateRequiredProperties();</span><br><span class="line">16 </span><br><span class="line">17    //保存容器中的一些早期的事件</span><br><span class="line">18    this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();</span><br><span class="line">19 &#125;</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>获取刷新后的内部Bean工厂，obtainFreshBeanFactory方法为内部bean工厂重新生成id，并返回bean工厂<br>AbstractApplicationContext. obtainFreshBeanFactory()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123;</span><br><span class="line"> 2 　　//为beanfactory生成唯一序列化id，beanfactory已经在GenericApplicationContext构造函数中初始化了，refreshBeanFactory的逻辑在AbstractApplicationContext的实现类GenericApplicationContext中</span><br><span class="line"> 3  refreshBeanFactory();</span><br><span class="line"> 4　　 //获取beanfactory</span><br><span class="line"> 5    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"> 6    if (logger.isDebugEnabled()) &#123;</span><br><span class="line"> 7       logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);</span><br><span class="line"> 8    &#125;</span><br><span class="line"> 9    return beanFactory;</span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>GenericApplicationContext.refreshBeanFactory()实现代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 protected final void refreshBeanFactory() throws IllegalStateException &#123;</span><br><span class="line">2    if (!this.refreshed.compareAndSet(false, true)) &#123;</span><br><span class="line">3       throw new IllegalStateException(</span><br><span class="line">4             &quot;GenericApplicationContext does not support multiple refresh attempts: just call &apos;refresh&apos; once&quot;);</span><br><span class="line">5    &#125;</span><br><span class="line">6 　　//生成一个序列化id</span><br><span class="line">7    this.beanFactory.setSerializationId(getId());</span><br><span class="line">8 &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里使用AbstractApplicationContext. refreshBeanFactory()在不同实现容器中有点区别，如果是以xml方式配置bean，会使用AbstractRefreshableApplicationContext容器中的实现，该容器中实现xml配置文件定位，并通过BeanDefinition载入和解析xml配置文件。<br>而如果是注解的方式，则并没有解析项目包下的注解，而是通过在refresh()方法中执行ConfigurationClassPostProcessor后置处理器完成对bean的加载.</p>
<p>3.BeanFactory的预准备工作<br>prepareBeanFactory主要完成beanFactory的一些属性设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">1 protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line"> 2    // Tell the internal bean factory to use the context&apos;s class loader etc.</span><br><span class="line"> 3    beanFactory.setBeanClassLoader(getClassLoader());  //设置类加载器</span><br><span class="line"> 4    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); //bean表达式解析器</span><br><span class="line"> 5    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));</span><br><span class="line"> 6 </span><br><span class="line"> 7    // Configure the bean factory with context callbacks.</span><br><span class="line"> 8    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));  //添加一个BeanPostProcessor实现ApplicationContextAwareProcessor</span><br><span class="line"> 9 //设置忽略的自动装配接口，表示这些接口的实现类不允许通过接口自动注入</span><br><span class="line">10    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">11    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">12    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);</span><br><span class="line">13    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);</span><br><span class="line">14    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);</span><br><span class="line">15    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);</span><br><span class="line">16 </span><br><span class="line">17    // BeanFactory interface not registered as resolvable type in a plain factory.</span><br><span class="line">18    // MessageSource registered (and found for autowiring) as a bean.</span><br><span class="line">19 //注册可以自动装配的组件，就是可以在任何组件中允许自动注入的组件</span><br><span class="line">20    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">21    beanFactory.registerResolvableDependency(ResourceLoader.class, this);</span><br><span class="line">22    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);</span><br><span class="line">23    beanFactory.registerResolvableDependency(ApplicationContext.class, this);</span><br><span class="line">24 </span><br><span class="line">25    // Register early post-processor for detecting inner beans as ApplicationListeners.</span><br><span class="line">26    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));</span><br><span class="line">27 </span><br><span class="line">28    //添加编译时的AspectJ</span><br><span class="line">29    if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">30       beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">31       // Set a temporary ClassLoader for type matching.</span><br><span class="line">32       beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">33    &#125;</span><br><span class="line">34 </span><br><span class="line">35    // 给beanfactory容器中注册组件ConfigurableEnvironment、systemProperties、systemEnvironment</span><br><span class="line">36    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">37       beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">38    &#125;</span><br><span class="line">39    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">40       beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">41    &#125;</span><br><span class="line">42    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">43       beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">44    &#125;</span><br><span class="line">45 &#125;</span><br></pre></td></tr></table></figure></p>
<p>4.invokeBeanFactoryPostProcessors 执行bean工厂后置处理器<br> AbstractApplicationContext. invokeBeanFactoryPostProcessors方法实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> 1 protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line"> 2    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line"> 3 </span><br><span class="line"> 4    // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime</span><br><span class="line"> 5    // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)</span><br><span class="line"> 6    if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line"> 7       beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line"> 8       beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line"> 9    &#125;</span><br><span class="line">10 &#125;</span><br></pre></td></tr></table></figure></p>
<p>invokeBeanFactoryPostProcessors方法内部执行实现了BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor这两个接口的Processor，先获取所有BeanDefinitionRegistryPostProcessor的实现，按优先级执行（是否实现PriorityOrdered优先级接口，是否实现Ordered顺序接口）；再以相同的策略执行所有BeanFactoryPostProcessor的实现。<br>PostProcessorRegistrationDelegate. invokeBeanFactoryPostProcessors实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">1 public static void invokeBeanFactoryPostProcessors(</span><br><span class="line">  2       ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123;</span><br><span class="line">  3 </span><br><span class="line">  4    // Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br><span class="line">  5    Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();</span><br><span class="line">  6 </span><br><span class="line">  7    if (beanFactory instanceof BeanDefinitionRegistry) &#123;</span><br><span class="line">  8       BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;</span><br><span class="line">  9       List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line"> 10       List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();</span><br><span class="line"> 11 </span><br><span class="line"> 12       for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;</span><br><span class="line"> 13          if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123;</span><br><span class="line"> 14             BeanDefinitionRegistryPostProcessor registryProcessor =</span><br><span class="line"> 15                   (BeanDefinitionRegistryPostProcessor) postProcessor;</span><br><span class="line"> 16             registryProcessor.postProcessBeanDefinitionRegistry(registry);</span><br><span class="line"> 17             registryProcessors.add(registryProcessor);</span><br><span class="line"> 18          &#125;</span><br><span class="line"> 19          else &#123;</span><br><span class="line"> 20             regularPostProcessors.add(postProcessor);</span><br><span class="line"> 21          &#125;</span><br><span class="line"> 22       &#125;</span><br><span class="line"> 23 </span><br><span class="line"> 24       // Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line"> 25       // uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line"> 26       // Separate between BeanDefinitionRegistryPostProcessors that implement</span><br><span class="line"> 27       // PriorityOrdered, Ordered, and the rest.</span><br><span class="line"> 28       List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();</span><br><span class="line"> 29 </span><br><span class="line"> 30       // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.</span><br><span class="line"> 31       String[] postProcessorNames =</span><br><span class="line"> 32             beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line"> 33       for (String ppName : postProcessorNames) &#123;</span><br><span class="line"> 34          if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line"> 35             currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line"> 36             processedBeans.add(ppName);</span><br><span class="line"> 37          &#125;</span><br><span class="line"> 38       &#125;</span><br><span class="line"> 39       sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line"> 40       registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"> 41       invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line"> 42       currentRegistryProcessors.clear();</span><br><span class="line"> 43 </span><br><span class="line"> 44       // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br><span class="line"> 45       postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line"> 46       for (String ppName : postProcessorNames) &#123;</span><br><span class="line"> 47          if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line"> 48             currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line"> 49             processedBeans.add(ppName);</span><br><span class="line"> 50          &#125;</span><br><span class="line"> 51       &#125;</span><br><span class="line"> 52       sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line"> 53       registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"> 54       invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line"> 55       currentRegistryProcessors.clear();</span><br><span class="line"> 56 </span><br><span class="line"> 57       // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.</span><br><span class="line"> 58       boolean reiterate = true;</span><br><span class="line"> 59       while (reiterate) &#123;</span><br><span class="line"> 60          reiterate = false;</span><br><span class="line"> 61          postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);</span><br><span class="line"> 62          for (String ppName : postProcessorNames) &#123;</span><br><span class="line"> 63             if (!processedBeans.contains(ppName)) &#123;</span><br><span class="line"> 64                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));</span><br><span class="line"> 65                processedBeans.add(ppName);</span><br><span class="line"> 66                reiterate = true;</span><br><span class="line"> 67             &#125;</span><br><span class="line"> 68          &#125;</span><br><span class="line"> 69          sortPostProcessors(currentRegistryProcessors, beanFactory);</span><br><span class="line"> 70          registryProcessors.addAll(currentRegistryProcessors);</span><br><span class="line"> 71          invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);</span><br><span class="line"> 72          currentRegistryProcessors.clear();</span><br><span class="line"> 73       &#125;</span><br><span class="line"> 74 </span><br><span class="line"> 75       // Now, invoke the postProcessBeanFactory callback of all processors handled so far.</span><br><span class="line"> 76       invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);</span><br><span class="line"> 77       invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);</span><br><span class="line"> 78    &#125;</span><br><span class="line"> 79 </span><br><span class="line"> 80    else &#123;</span><br><span class="line"> 81       // Invoke factory processors registered with the context instance.</span><br><span class="line"> 82       invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);</span><br><span class="line"> 83    &#125;</span><br><span class="line"> 84 </span><br><span class="line"> 85    // Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line"> 86    // uninitialized to let the bean factory post-processors apply to them!</span><br><span class="line"> 87    String[] postProcessorNames =</span><br><span class="line"> 88          beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);</span><br><span class="line"> 89 </span><br><span class="line"> 90    // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,</span><br><span class="line"> 91    // Ordered, and the rest.</span><br><span class="line"> 92    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line"> 93    List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line"> 94    List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line"> 95    for (String ppName : postProcessorNames) &#123;</span><br><span class="line"> 96       if (processedBeans.contains(ppName)) &#123;</span><br><span class="line"> 97          // skip - already processed in first phase above</span><br><span class="line"> 98       &#125;</span><br><span class="line"> 99       else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">100          priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));</span><br><span class="line">101       &#125;</span><br><span class="line">102       else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">103          orderedPostProcessorNames.add(ppName);</span><br><span class="line">104       &#125;</span><br><span class="line">105       else &#123;</span><br><span class="line">106          nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">107       &#125;</span><br><span class="line">108    &#125;</span><br><span class="line">109 </span><br><span class="line">110    // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.</span><br><span class="line">111    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">112    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">113 </span><br><span class="line">114    // Next, invoke the BeanFactoryPostProcessors that implement Ordered.</span><br><span class="line">115    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">116    for (String postProcessorName : orderedPostProcessorNames) &#123;</span><br><span class="line">117       orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">118    &#125;</span><br><span class="line">119    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">120    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">121 </span><br><span class="line">122    // Finally, invoke all other BeanFactoryPostProcessors.</span><br><span class="line">123    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">124    for (String postProcessorName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">125       nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));</span><br><span class="line">126    &#125;</span><br><span class="line">127    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);</span><br><span class="line">128 </span><br><span class="line">129    // Clear cached merged bean definitions since the post-processors might have</span><br><span class="line">130    // modified the original metadata, e.g. replacing placeholders in values...</span><br><span class="line">131    beanFactory.clearMetadataCache();</span><br><span class="line">132 &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面在处理BeanDefinitionRegistryPostProcessors时有一个非常重要的过程，AnnotationConfigApplicationContext构造函数在初始化reader时为内部beanFactory容器初始化了一个id为org.springframework.context.annotation.internalConfigurationAnnotationProcessor的组件，这是一个ConfigurationClassPostProcessor组件，用来处理添加@Configuration注解的类，并将Bean定义注册到BeanFactory中。<br>5.注册BeanPostProcessor（Bean的后置处理器）,用于拦截bean创建过程<br>注册后置处理器的大致逻辑是：</p>
<p>　　1.获取所有的 BeanPostProcessor</p>
<p>　　2.根据处理器实现的接口区分出4中类型：</p>
<p>　　　　a.实现PriorityOrdered接口的处理器</p>
<p>　　　　b.实现Ordered接口的处理器，</p>
<p>　　　　c.实现MergedBeanDefinitionPostProcessor接口的处理器，</p>
<p>　　　　d.普通后置处理器</p>
<p>　　3.按这个4中类型依次注册到容器中</p>
<p>　　4.注册一个特殊的后置处理器ApplicationListenerDetector，ApplicationListenerDetector本身也实现了MergedBeanDefinitionPostProcessor接口，有个问题，这个为什么没有在上面c,d之间注册，而是放到最后？</p>
<p>AbstractApplicationContext .registerBeanPostProcessors(beanFactory);实现逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">2    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);</span><br><span class="line">3 &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"> 1 public static void registerBeanPostProcessors(</span><br><span class="line"> 2       ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) &#123;</span><br><span class="line"> 3 </span><br><span class="line"> 4    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</span><br><span class="line"> 5 </span><br><span class="line"> 6    // Register BeanPostProcessorChecker that logs an info message when</span><br><span class="line"> 7    // a bean is created during BeanPostProcessor instantiation, i.e. when</span><br><span class="line"> 8    // a bean is not eligible for getting processed by all BeanPostProcessors.</span><br><span class="line"> 9    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;</span><br><span class="line">10    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));</span><br><span class="line">11 </span><br><span class="line">12    // Separate between BeanPostProcessors that implement PriorityOrdered,</span><br><span class="line">13    // Ordered, and the rest.</span><br><span class="line">14 //按优先级分类</span><br><span class="line">15    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">16    List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">17    List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">18    List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();</span><br><span class="line">19    for (String ppName : postProcessorNames) &#123;</span><br><span class="line">20       if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;</span><br><span class="line">21          BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">22          priorityOrderedPostProcessors.add(pp);</span><br><span class="line">23          if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">24             internalPostProcessors.add(pp);</span><br><span class="line">25          &#125;</span><br><span class="line">26       &#125;</span><br><span class="line">27       else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;</span><br><span class="line">28          orderedPostProcessorNames.add(ppName);</span><br><span class="line">29       &#125;</span><br><span class="line">30       else &#123;</span><br><span class="line">31          nonOrderedPostProcessorNames.add(ppName);</span><br><span class="line">32       &#125;</span><br><span class="line">33    &#125;</span><br><span class="line">34 </span><br><span class="line">35    //先注册实现PriorityOrdered接口的处理器，添加到beanfactory容器中beanFactory.addBeanPostProcessor(postProcessor);</span><br><span class="line">36    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);</span><br><span class="line">37    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);</span><br><span class="line">38 </span><br><span class="line">39    //注册实现Ordered接口的处理器</span><br><span class="line">40    List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">41    for (String ppName : orderedPostProcessorNames) &#123;</span><br><span class="line">42       BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">43       orderedPostProcessors.add(pp);</span><br><span class="line">44       if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">45          internalPostProcessors.add(pp);</span><br><span class="line">46       &#125;</span><br><span class="line">47    &#125;</span><br><span class="line">48    sortPostProcessors(orderedPostProcessors, beanFactory);</span><br><span class="line">49    registerBeanPostProcessors(beanFactory, orderedPostProcessors);</span><br><span class="line">50 </span><br><span class="line">51    // 注册没有实现Ordered或PriorityOrdered的处理器（nonOrderedPostProcessors）</span><br><span class="line">52    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();</span><br><span class="line">53    for (String ppName : nonOrderedPostProcessorNames) &#123;</span><br><span class="line">54       BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);</span><br><span class="line">55       nonOrderedPostProcessors.add(pp);</span><br><span class="line">56       if (pp instanceof MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">57          internalPostProcessors.add(pp);</span><br><span class="line">58       &#125;</span><br><span class="line">59    &#125;</span><br><span class="line">60    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);</span><br><span class="line">61 </span><br><span class="line">62    // Finally, re-register all internal BeanPostProcessors.</span><br><span class="line">63 　　//最后，重新注册所有internal BeanPostProcessors（实现MergedBeanDefinitionPostProcessor接口的后置处理器</span><br><span class="line">64 65    sortPostProcessors(internalPostProcessors, beanFactory);</span><br><span class="line">66    registerBeanPostProcessors(beanFactory, internalPostProcessors);</span><br><span class="line">67 </span><br><span class="line">68    //注册ApplicationListenerDetector，用于Bean创建完时检查是否是ApplicationListener</span><br><span class="line">69    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));</span><br><span class="line">70 &#125;</span><br></pre></td></tr></table></figure>
<p>6.初始化MessageSource组件（做国际化功能；消息绑定，消息解析）<br>AbstractApplicationContext .initMessageSource()方法实现代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> 1 protected void initMessageSource() &#123;</span><br><span class="line"> 2 //获取beanFactory</span><br><span class="line"> 3    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"> 4 //判断是否已经存在id为MESSAGE_SOURCE_BEAN_NAME的组件</span><br><span class="line"> 5    if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) &#123;</span><br><span class="line"> 6       this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);</span><br><span class="line"> 7       // Make MessageSource aware of parent MessageSource.</span><br><span class="line"> 8       if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) &#123;</span><br><span class="line"> 9          HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;</span><br><span class="line">10          if (hms.getParentMessageSource() == null) &#123;</span><br><span class="line">11             // Only set parent context as parent MessageSource if no parent MessageSource</span><br><span class="line">12             // registered already.</span><br><span class="line">13             hms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">14          &#125;</span><br><span class="line">15       &#125;</span><br><span class="line">16       if (logger.isDebugEnabled()) &#123;</span><br><span class="line">17          logger.debug(&quot;Using MessageSource [&quot; + this.messageSource + &quot;]&quot;);</span><br><span class="line">18       &#125;</span><br><span class="line">19    &#125;</span><br><span class="line">20    else &#123;</span><br><span class="line">21       // Use empty MessageSource to be able to accept getMessage calls.</span><br><span class="line">22       DelegatingMessageSource dms = new DelegatingMessageSource();</span><br><span class="line">23       dms.setParentMessageSource(getInternalParentMessageSource());</span><br><span class="line">24       this.messageSource = dms;</span><br><span class="line">25       beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);</span><br><span class="line">26       if (logger.isDebugEnabled()) &#123;</span><br><span class="line">27          logger.debug(&quot;Unable to locate MessageSource with name &apos;&quot; + MESSAGE_SOURCE_BEAN_NAME +</span><br><span class="line">28                &quot;&apos;: using default [&quot; + this.messageSource + &quot;]&quot;);</span><br><span class="line">29       &#125;</span><br><span class="line">30    &#125;</span><br><span class="line">31 &#125;</span><br></pre></td></tr></table></figure></p>
<p>7.初始化事件派发器<br> AbstractApplicationContext .initApplicationEventMulticaster()方法实现逻辑<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> 1 protected void initApplicationEventMulticaster() &#123;</span><br><span class="line"> 2 //获取BeanFactory</span><br><span class="line"> 3    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line"> 4 //如果有配置beanName为applicationEventMulticaster的事件派发器，则将其赋给容器中的applicationEventMulticaster对象</span><br><span class="line"> 5    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line"> 6       this.applicationEventMulticaster =</span><br><span class="line"> 7             beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line"> 8       if (logger.isDebugEnabled()) &#123;</span><br><span class="line"> 9          logger.debug(&quot;Using ApplicationEventMulticaster [&quot; + this.applicationEventMulticaster + &quot;]&quot;);</span><br><span class="line">10       &#125;</span><br><span class="line">11    &#125;</span><br><span class="line">12    else &#123;</span><br><span class="line">13 //不存在，则创建一个SimpleApplicationEventMulticaster事件派发器，并注册到beanfactory中</span><br><span class="line">14       this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">15       beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);</span><br><span class="line">16       if (logger.isDebugEnabled()) &#123;</span><br><span class="line">17          logger.debug(&quot;Unable to locate ApplicationEventMulticaster with name &apos;&quot; +</span><br><span class="line">18                APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line">19                &quot;&apos;: using default [&quot; + this.applicationEventMulticaster + &quot;]&quot;);</span><br><span class="line">20       &#125;</span><br><span class="line">21    &#125;</span><br><span class="line">22 &#125;</span><br></pre></td></tr></table></figure></p>
<ol start="8">
<li><p>注册时间监听器，将项目里面的ApplicationListener注册到容器中来<br>registerListeners方法主要实现将事件监听器添加到IOC容器中的事件派发器中，并在最后做了一个事件发布的逻辑(如果之前的步骤有产生事件，则将earlyApplicationEvents中保存的事件逐一发布)</p>
<p>AbstractApplicationContext .registerListeners()方法实现逻辑：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> protected void registerListeners() &#123;</span><br><span class="line"> 2    // Register statically specified listeners first.</span><br><span class="line"> 3    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line"> 4       getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line"> 5    &#125;</span><br><span class="line"> 6 </span><br><span class="line"> 7    // Do not initialize FactoryBeans here: We need to leave all regular beans</span><br><span class="line"> 8    // uninitialized to let post-processors apply to them!</span><br><span class="line"> 9    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);</span><br><span class="line">10    for (String listenerBeanName : listenerBeanNames) &#123;</span><br><span class="line">11       getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);</span><br><span class="line">12    &#125;</span><br><span class="line">13 </span><br><span class="line">14    // Publish early application events now that we finally have a multicaster...</span><br><span class="line">15    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;</span><br><span class="line">16    this.earlyApplicationEvents = null;</span><br><span class="line">17    if (earlyEventsToProcess != null) &#123;</span><br><span class="line">18       for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;</span><br><span class="line">19          getApplicationEventMulticaster().multicastEvent(earlyEvent);</span><br><span class="line">20       &#125;</span><br><span class="line">21    &#125;</span><br><span class="line">22 &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化所有剩下的单实例bean,单例bean在初始化容器时创建，原型bean在获取时（getbean）时创建<br>AbstractApplicationContext.finishBeanFactoryInitialization(beanFactory);方法实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1 protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line"> 2    //组件转换器相关</span><br><span class="line"> 3    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line"> 4          beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line"> 5       beanFactory.setConversionService(</span><br><span class="line"> 6             beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line"> 7    &#125;</span><br><span class="line"> 8 </span><br><span class="line"> 9    // Register a default embedded value resolver if no bean post-processor</span><br><span class="line">10    // (such as a PropertyPlaceholderConfigurer bean) registered any before:</span><br><span class="line">11    // at this point, primarily for resolution in annotation attribute values.</span><br><span class="line">12    if (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">13       beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">14    &#125;</span><br><span class="line">15 </span><br><span class="line">16    //aspectj相关.</span><br><span class="line">17    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);</span><br><span class="line">18    for (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">19       getBean(weaverAwareName);</span><br><span class="line">20    &#125;</span><br><span class="line">21 </span><br><span class="line">22    // Stop using the temporary ClassLoader for type matching.</span><br><span class="line">23    beanFactory.setTempClassLoader(null);</span><br><span class="line">24 </span><br><span class="line">25    // Allow for caching all bean definition metadata, not expecting further changes.</span><br><span class="line">26    beanFactory.freezeConfiguration();</span><br><span class="line">27 </span><br><span class="line">28    // 初始化后剩下的单实例bean</span><br><span class="line">29    beanFactory.preInstantiateSingletons();</span><br><span class="line">30 &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>DefaultListableBeanFactory. preInstantiateSingletons()方法实现逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">1 public void preInstantiateSingletons() throws BeansException &#123;</span><br><span class="line"> 2    if (logger.isDebugEnabled()) &#123;</span><br><span class="line"> 3       logger.debug(&quot;Pre-instantiating singletons in &quot; + this);</span><br><span class="line"> 4    &#125;</span><br><span class="line"> 5 </span><br><span class="line"> 6    // Iterate over a copy to allow for init methods which in turn register new bean definitions.</span><br><span class="line"> 7    // While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span><br><span class="line"> 8 　　//容器中所有bean名称</span><br><span class="line"> 9    List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);</span><br><span class="line">10 </span><br><span class="line">11    // Trigger initialization of all non-lazy singleton beans...</span><br><span class="line">12    for (String beanName : beanNames) &#123;</span><br><span class="line">13 　　//获取Bean的定义信息；RootBeanDefinition</span><br><span class="line">14       RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">15 　　//非抽象，单例，非延迟加载</span><br><span class="line">16       if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">17 　　//是否是FactoryBean</span><br><span class="line">18          if (isFactoryBean(beanName)) &#123;</span><br><span class="line">19     // 通过&quot;&amp;beanName&quot;获取工厂Bean实例</span><br><span class="line">20             Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">21             if (bean instanceof FactoryBean) &#123;</span><br><span class="line">22                final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">23                boolean isEagerInit;</span><br><span class="line">24                if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123;</span><br><span class="line">25                   isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">26                               ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">27                         getAccessControlContext());</span><br><span class="line">28                &#125;</span><br><span class="line">29                else &#123;</span><br><span class="line">30                   isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp;</span><br><span class="line">31                         ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">32                &#125;</span><br><span class="line">33                if (isEagerInit) &#123;</span><br><span class="line">34                   getBean(beanName);</span><br><span class="line">35                &#125;</span><br><span class="line">36             &#125;</span><br><span class="line">37          &#125;</span><br><span class="line">38          else &#123;</span><br><span class="line">39 　　　　　　//不是FactoryBean,则利用getBean(beanName)实例化bean </span><br><span class="line">40             getBean(beanName);</span><br><span class="line">41          &#125;</span><br><span class="line">42       &#125;</span><br><span class="line">43    &#125;</span><br><span class="line">44 </span><br><span class="line">45    // Trigger post-initialization callback for all applicable beans...</span><br><span class="line">46    for (String beanName : beanNames) &#123;</span><br><span class="line">47       Object singletonInstance = getSingleton(beanName);</span><br><span class="line">48       if (singletonInstance instanceof SmartInitializingSingleton) &#123;</span><br><span class="line">49          final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">50          if (System.getSecurityManager() != null) &#123;</span><br><span class="line">51             AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">52                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">53                return null;</span><br><span class="line">54             &#125;, getAccessControlContext());</span><br><span class="line">55          &#125;</span><br><span class="line">56          else &#123;</span><br><span class="line">57             smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">58          &#125;</span><br><span class="line">59       &#125;</span><br><span class="line">60    &#125;</span><br><span class="line">61 &#125;</span><br></pre></td></tr></table></figure></p>
<ol start="10">
<li>完成BeanFactory的初始化创建工作，IOC容器就创建完成<br>AbstractApplicationContext.finishRefresh()实现逻辑：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 1 protected void finishRefresh() &#123;</span><br><span class="line"> 2    // Clear context-level resource caches (such as ASM metadata from scanning).</span><br><span class="line"> 3    clearResourceCaches();</span><br><span class="line"> 4 </span><br><span class="line"> 5    //初始化和生命周期有关的后置处理器LifecycleProcessor，默认DefaultLifecycleProcessor</span><br><span class="line"> 6    initLifecycleProcessor();</span><br><span class="line"> 7 </span><br><span class="line"> 8    // 回调生命周期处理器</span><br><span class="line"> 9    getLifecycleProcessor().onRefresh();</span><br><span class="line">10 </span><br><span class="line">11    //发布容器刷新完成事件：ContextRefreshedEvent</span><br><span class="line">12    publishEvent(new ContextRefreshedEvent(this));</span><br><span class="line">13 </span><br><span class="line">14    LiveBeansView.registerApplicationContext(this);</span><br><span class="line">15 &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>以上基本分析了AnnotationConfigApplicationContext容器的初始化过程， Spring容器在启动过程中，会先保存所有注册进来的Bean的定义信息；Spring容器根据条件创建Bean实例，区分单例，还是原型，后置处理器等（后置处理器会在容器创建过程中通过getBean创建，并执行相应的逻辑）；Spring容器在创建bean实例后，会使用多种后置处理器来增加bean的功能，比如处理自动注入，AOP，异步，这种后置处理器机制也丰富了bean的功能。</p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/blog/tags/Spring/">Spring</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/blog/2019/06/23/elegant/tomcat/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">java语法糖</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/blog/2019/05/31/mysql/mysql/">
        <span class="next-text nav-default">MySQL查询语句中的IN 和Exists 对比分析</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2019
    <span class="footer-author">John Doe.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/blog/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/blog/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/blog/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
